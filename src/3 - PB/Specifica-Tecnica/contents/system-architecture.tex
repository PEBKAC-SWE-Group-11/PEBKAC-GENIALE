\section{Architettura di sistema }
\subsection{Modello architetturale}
Il sistema è stato progettato seguendo l'\textbf{architettura esagonale}, un modello che mira alla separazione tra business logic dell'applicazione e i servizi esterni, le fonti dati e le interfacce utente. Questa struttura pone il core\textsubscript{G} al centro, circondato da ports\textsubscript{G} che fungono da interfaccia tra il core\textsubscript{G} e il mondo esterno.

Il \textbf{core\textsubscript{G}} dell'applicazione è il fulcro del sistema, che contiene la logica di dominio e le regole di business. La sua progettazione punta ad evitare riferimenti diretti a dettagli tecnologici specifici, promuovendo l'indipendenza dal contesto esterno.

Le \textbf{ports\textsubscript{G}} costituiscono il confine tra il core\textsubscript{G} dell'applicazione e l'esterno, garantendo una comunicazione strutturata. Esistono due tipi di ports\textsubscript{G}: 
\begin{itemize}
    \item Inbound Port (o Use Case): per le invocazioni del core\textsubscript{G} da parte di componenti esterni, attraverso un'interfaccia definita. Sono in pratica dei punti di accesso al core\textsubscript{G} e isolano la logica di dominio da implementazioni specifiche;
    \item Outbound Port: consentono al core\textsubscript{G} di accedere a funzionalità esterne (e.g. interazione con librerie esterne\textsubscript{G} o sistemi di persistenza). Mettono a disposizione un'astrazione che preserva l'indipendenza del core\textsubscript{G} dai dettagli tecnici specifici. 
\end{itemize}

I \textbf{services\textsubscript{G}} costituiscono il livello più esterno dell'applicazione, fanno parte della business logic. L'implementazione dei services\textsubscript{G} si concentra sulla logica di dominio, senza preoccuparsi degli aspetti tencologici specifici.

Gli \textbf{adapters\textsubscript{G}} formano il livello più esterno dell'applicazione. Esistono due tipi di adapters\textsubscript{G}: 
\begin{itemize}
    \item Input Adapters\textsubscript{G} (o Controllers): invocano operazioni sulle Inbound Port, traducendo le azioni provenienti dall'esterno in chiamate alle ports\textsubscript{G} in ingresso al core\textsubscript{G}, rendendo le richieste esterne comprensibili per il core\textsubscript{G};
    \item Output Adapters\textsubscript{G}: invocano operazioni sulle Outbound Port, traducendo le azioni del core\textsubscript{G} in operazioni comprensibili per il mondo esterno.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{images/HEX.png}
    \caption{Rappresentazione dell'architettura esagonale}
    \label{fig:architettura}
\end{figure}

\subsection{Componenti}
L'architettura del sistema è suddivisa in:
\begin{itemize}
    \item Frontend: si occupa di fornire un'interfaccia grafica all'utente per interagire col sistema. Inoltra le domande dell'utente al backend e visualizza i risultati;
    \item Backend: si occupa di elaborare le richieste degli utenti, interagendo con il sistema di persistenza e i servizi esterni, in particolare dialoga con il database vettoriale e con gli LLM;
    \item Database: è responsabile della memorizzazione della documentazione per la RAG e delle chat con relativi messaggi.
\end{itemize}
\subsubsection{Assemblaggio delle componenti}
Le componenti sono assemblate tramite Docker Compose, per facilitare l'esecuzione e la gestione di più container docker. 
In particolare sono stati prodotti i seguenti container:
\begin{itemize}
    \item pgvector: espone l'istanza del database sulla porta 5432, permettendo al backend di accedere ai relativi dati;
    \item app: espone la componente di backend sulla porta 5001, dando al frontend la possibilità di accedere ai servizi offerti;
    \item frontend: espone l'applicazione web sulla porta 4200, dando la possibilità all'utente di connettersi e interagire col sistema;
    \item data processing: responsabile dello scraping, dell'indicizzazione e salvataggio nel DB.
\end{itemize}
\subsection{Struttura del sistema}
\subsubsection{Frontend}
\begin{itemize}
\item L'approccio adottato per lo sviluppo del front-end\textsubscript{G} si basa su una combinazione flessibile di pattern e pratiche tipiche del framework Angular\textsubscript{G}, senza aderire rigidamente a un unico schema architetturale come MVC\textsubscript{G} o MVVM\textsubscript{G}. Questa scelta consente di bilanciare modularità, scalabilità e semplicità nella gestione dello stato, adattandosi alle specifiche esigenze del progetto. 
\item La struttura dell'applicazione si articola in due aree funzionali ben distinte (utente e amministrativa), basate su componenti standalone\textsubscript{G} — come SidebarComponent, ChatboxComponent e AppComponent per l'area utente; AdminLoginComponent e AdminDashboardComponent per l'area amministrativa — supportati da servizi dedicati quali ApiService e ChatService. I componenti sono responsabili della presentazione, mentre i servizi gestiscono la comunicazione con il back-end\textsubscript{G} tramite API RESTful\textsubscript{G} (nel caso di ApiService) e centralizzano la logica di business e lo stato (come in ChatService). 
\item In questo modo, operazioni quali la creazione di conversazioni, l'invio di messaggi o la gestione dei feedback vengono delegate ai servizi, rendendo i componenti più leggeri e riutilizzabili. La gestione dello stato è un elemento chiave dell'architettura: l'introduzione di un servizio come ChatService, che utilizza il pattern Observer\textsubscript{G} tramite BehaviorSubject\textsubscript{G} di RxJS\textsubscript{G} per centralizzare conversazioni, messaggi e conversazione attiva, consente ai componenti di reagire dinamicamente ai cambiamenti attraverso gli observable. Questo garantisce un'interfaccia utente\textsubscript{G} reattiva e fluida, resa possibile grazie a strumenti asincroni come async/await\textsubscript{G} e firstValueFrom\textsubscript{G}.
\item La sicurezza è gestita attraverso meccanismi appropriati al contesto: sessioni utente anonime persistenti tramite localStorage\textsubscript{G} per l'area chat, e autenticazione basata su hash SHA-256\textsubscript{G} con token JWT\textsubscript{G} per l'area amministrativa, implementata tramite interceptor HTTP\textsubscript{G}.
\end{itemize}
\subsubsubsection{Componenti principali}
\subsubsubsection*{AppComponent}
Si tratta del componente padre che gestisce la corretta comunicazioni tra i due componenti figli SidebarComponent e ChatboxComponent (i quali fanno parte dei Componenti Principali). Coordina l'interfaccia grafica utente principale e gestisce la visibilità della Sidebar nella situazione in cui l'applicativo viene utilizzato da mobile attraverso:
\begin{itemize}
    \item \texttt{toggleSidebar()} - pulsante visibile solo in modalità mobile che permette la visualizzazione della lista di conversazioni;
    \item \texttt{closeSidebarOnMobile()} - funzione che si attiva in seguito alla selezione di una delle conversazioni presenti nella lista o in seguito alla creazione di una nuova conversazione, lasciando spazio allo spazio dedicato ai messaggi. 
\end{itemize}
\subsubsubsection*{ChatboxComponent}
Primo dei due componenti figli di AppComponent il cui ruolo principale è quello di fornire all'utente la corretta visualizzazione e invio dei messaggi e dei feedback. Questo è possibile grazie ai metodi:
\begin{itemize}
    \item \texttt{sendMessage()} - responabile dell'invio di un messaggio valido da parte dell'utente, ovvero un messaggio che non superi i caratteri limite o che non sia vuoto;
    \item \texttt{sendPositiveFeedback()} - gestione dei feedback positivi;
    \item \texttt{sendNegativeFeedback()} - gestione dei feedback negativi;
    \item \texttt{submitFeedback()} - conferma del feedback che si intende mandare, il quale può essere positivo o negativo, vuoto o commentato.
\end{itemize}
\subsubsubsection*{SidebarComponent}
Componente responsabile della gestione e visualizzazione della lista di conversazioni. I metodi che permettono ciò sono i seguenti:
\begin{itemize}
    \item \texttt{createNewConversation()} - crea una nuova conversazione e può essere invocato in due situazioni: quando si vuole creare una conversazione nuovo tramite il pulsante dedicato oppure quando si cerca di cancellare una conversazione attiva, ovvero una conversazione che l'utente sta utilizzando o visualizzando nel momento della sua cancellazione. Dunque, al posto della conversazione eliminata viene creata di default una nuova conversazione;
    \item \texttt{selectConversation()} - selezione di una conversazione esistente nella lista, la quale dopo la sua selezione viene contrassegnata come 'attivia';
    \item \texttt{deleteConversation()} - cancellazione di una delle conversazioni esistenti (il comportamento della funzione quando si cerca di cancellare una conversazione attiva è già stato descritto sopra)
\end{itemize}
I metodi descritti in questo paragrafo sono tutti gestiti dai servizi implementati nel frontend.
\subsubsubsection{Servizi}
\subsubsubsection*{ChatService}
Come anticipato precedentemente, i metodi utilizzati nei componenti figli sono implementati in ChatService, che ha il compito di gestire la comunicazione tra le richieste dei componenti del frontend e il backend. I metodi principali sono:
\begin{itemize}
    \item \texttt{initializeFromStorage()} - metodo chiave grazie al quale è possibile l'inizializzazione dell'applicativo attraverso il controlla della presenza o meno di un ID di sessione nel localStorage. Se questo è già presente allora vengono recuperate tutte informazioni dipendenti dal ID conservato grazie a \texttt{readSession(sessionId)} e viene aggiornata la data di accesso con \texttt{updateSession(sessionId)}, altrimenti se ne genera una nuova conversazione con \texttt{createNewSession()};
    \item le altre funzioni sono già state discusse precedentemente.
\end{itemize}
\subsubsubsection*{ApiService}
Mentre ChatService contiene l'implementazione dei metodi utilizzati dai componenti figli, ApiService contiene le chiamate HTTP ai metodi CRUD presenti nel backend. Infatti, ApiService è iniettato in ChatService, e fa da tramite tra frontend e backend attraverso le API che mantengono una forma compattibile con le API scritte nel backend. Come si può intuire le chiamte principali gestiscono sessione, messaggi e feedback, e la maggior parte di queste sono già state discusse precedentemente. Tuttavia, ce ne sono alcune da analizzare:
\begin{itemize}
    \item \texttt{askQuestion(conversationId, question)} - viene chiamata all'interno del metodo \texttt{sendMessage()} in ChatService. Il suo scopo è quello di collegarsi all'algoritmo che genera la risposta nel backend. Si resta in attesa e non appena viene ritornata, si può visualizzare nella sezione dei messaggi della conversazione interessata;
    \item Admin 
    \newline \newline Le seguenti chiamate HTTP sono tutte necessarie per l'area riservata dell'amministratore
    \begin{itemize}
        \item \texttt{adminLogin(password)} - responsabile dell'autenticazione tramite password da parte dell'amministrazione per poter accedere alla Dashboard. Si specifica che si tratta di un'implementazione mock, accordata con il proponente. Tale argomento verrà trattato più approfonditamente successivamente;
        \item \texttt{getAdminStats()} - richiede dal backend i dati relativi al totale delle conversazioni e dei feedback creati dagli utenti. Si tratta quindi del recupero delle statistiche necessarie all'amministratore per comprendere l'andamento dell'applicativo;
        \item \texttt{getFeedbackWithComments} - funzionalità necessaria a recuperare i feedback dei messaggi che sono stati inviati con un commento annesso. Necessario agli svliuppatori in una fase iniziale in cui si prende atto delle osservazioni degli utenti con lo scopo di migliorare il prodotto in fasi successive. Feedback con messaggio e commento sono visibili nella Dashboard insieme alle statistice.
    \end{itemize}
\end{itemize}
\subsubsubsection{Area amministratore}
\subsubsubsection*{LoginComponent}
Per raggiungere questa sezione dell'applciativo è necessario modificare l'URL aggiungendo \texttt{/admin/login} che porta l'amministratore all'interfaccia grafica dedicata all'autenticazione dove basta inserire la password per poter accedere in seguito alla Dashboard (\texttt{/admin/dashboard}). Le funzioni principali sono:
\begin{itemize}
    \item \texttt{login()} - verifica la password inserita e autentica l'utente;
    \item \texttt{hashPassword} - calcolo dell'hash della password per la verifica.
\end{itemize}
Una volta autenticato, nel localStorage viene salvato il token generato durante l'accesso alla Dashboard.
\subsubsubsection*{DashboardComponent}
Come già discusso, nelle Dashboard si possono visualizzare le statisctiche amministrative e i feedback commentati degli utenti. Ciò è possibili grazie a:
\begin{itemize}
    \item \texttt{loadStats()} - carica le statistiche;
    \item \texttt{loadFeedbackComments} - carica i feedback commentati;
    \item \texttt{calcSatisfactionRate} - calcolo del tasso di soddisfazione degli utenti. 
\end{itemize}
Dalla Dashboard si possono fare due azioni, ritornare all'area utilizzata da un utente generico, ovvero alle conversazioni, tramite pulsante specifico, ma così facendo il token generato durante l'autenticazione è ancora presente nel localStorage, quindi l'amministratore in momemnti successivi può accedere all Dashboard senza dover ripetere la fase di autenticazione. Altrimenti, tramite pulsante specifico può fare 'Logout', così rimuovendo il token dal localStorage.
\subsubsubsection*{AuthInterceptor}
Intercetta le richieste HTTP per aggiungere token di autenticazione. Attraverso \texttt{intercept()} aggiunge l'header di autorizzazione alle richieste verso le rotte amministrative. È utilizzato globalmente per proteggere le rotte amministrative.
\subsubsubsection*{AdminGuard}
Protegge le rotte amministrative verificando l'autenticazione. Controlla se l'utente è autenticato prima di permettere l'accesso a una rotta attraverso \texttt{canActivate()}. È utilizzato nelle definizioni delle rotte per proteggere le sezioni amministrative.
\subsubsubsection{Design Pattern}
L'applicazione front-end implementa specifici pattern di progettazione software che ne definiscono l'architettura complessiva. La scelta di questi pattern si allinea con le best practice di Angular e con le esigenze progettuali.
\subsubsection*{Pattern creazionali}
\begin{itemize}
    \item Singleton
    \newline\newline L'intero sistema di dependency injection\textsubscript{G} di Angular implementa implicitamente questo pattern. Tutti i servizi (ApiService e ChatService) sono dichiarati con @Injectable{providedIn: 'root'}, garantendo un'unica istanza per l'intera applicazione. Grazie a questo sistema si riesce la centralizzazione dello stato dell'applicazione, la prevenzione di inconsistenze e l'ottimizzazione delle risorse attraverso il riuso delle istanze di servizio. 
\end{itemize}
\subsubsection*{Pattern strutturali}
\begin{itemize}
    \item Decorator
    \newline\newline Si usa il sistema nativo di decoratori TypeScript/Angular\textsubscript{G} (@Component, @Injectable, @Input e @Output) per estendere dinamicamente il comportamento delle classi e di AuthInterceptor per decorare le richieste HTTP. Così facendo si separano le responsabilità e si riutilizza il codice.
    \item Façade
    \newline\newline ApiService astrae le complessità delle chiamate HTTP e ChatService nasconde i dettagli implementativi della gestione delle conversazioni. Il vantaggio è il disaccoppiamento tra logica di business e interfaccia utente. 
\end{itemize}
\subsubsection*{Pattern comportamentali}
\begin{itemize}
    \item Observer
    \newline\newline Uso estensivo di BehaviorSubject e Observable di RxJS per gestire flussi di dati asincroni e aggiornamenti dell'interfaccia utente. 
    \item Mediator
    \newline\newline AppComponent funge da mediatore per la comunicazione tra componenti figli come SidebarComponent e ChatboxComponent. 
\end{itemize}

\subsubsubsection{Diagramma delle classi}

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{images/FrontendUML.png}
    \caption{Schema delle classi utilizzate nel frontend}
    \label{fig:architettura}
\end{figure}

\newpage
\subsubsection{Backend}
 Il sistema è architettato secondo il pattern esagonale (Ports and Adapters), dove il Core costituisce il dominio centrale dell'applicazione. Questa componente rappresenta il nucleo del sistema, caratterizzato da un isolamento completo dalle dipendenze esterne. Al suo interno sono contenute le regole di business fondamentali e le entità che definiscono i concetti chiave del dominio: le conversazioni, i messaggi e le sessioni. Il Core opera come un'unità autonoma, implementando la logica di business in modo indipendente dalle modalità di input/output dei dati.
\newline La comunicazione tra il Core e l'ambiente esterno è gestita attraverso le Porte, che definiscono le interfacce di interazione. Queste costituiscono i contratti formali attraverso i quali il Core stabilisce le modalità di comunicazione desiderate, astraendosi dalle implementazioni concrete. Le Porte rappresentano le specifiche tecniche che definiscono come il Core intende interagire con l'esterno, delegando la responsabilità dell'implementazione alle componenti periferiche.
\newline Il sistema è completato dagli Adattatori, che formano un layer periferico attorno al Core. Questi componenti implementano le interfacce definite dalle Porte, fungendo da intermediari tra il Core e le risorse esterne. Gli Adattatori si occupano della traduzione dei dati e delle richieste tra il dominio e l'ambiente esterno, garantendo che il Core rimanga isolato dalle specifiche implementative delle interfacce esterne.
\subsubsubsection{Componenti}
\subsubsubsubsection{Core - ConversationService}
Nel core del sistema, la classe \texttt{ConversationService} si occupa principalmente della gestione delle sessioni, delle conversazioni, dei messaggi e dei feedback.

\subsubsection*{Gestione delle sessioni}
Il servizio offre diversi metodi per la gestione delle sessioni:
\begin{itemize}
    \item \texttt{createSession()} permette di creare una nuova sessione;
    \item \texttt{readSession(sessionId)} recupera una sessione esistente dato un identificativo specifico;
    \item \texttt{updateSession(sessionId)} consente di aggiornare il timestamp di una sessione.
\end{itemize}

\subsubsection*{Gestione delle conversazioni}
Per quanto riguarda le conversazioni, il servizio gestisce:
\begin{itemize}
    \item \texttt{createConversation(sessionId)} crea una nuova conversazione associata a una sessione esistente;
    \item \texttt{readConversations(sessionId)} restituisce tutte le conversazioni relative a una sessione specifica;
    \item \texttt{readConversationById(conversationId)} permette di recuperare una conversazione in base al suo ID;
    \item \texttt{deleteConversation(conversationId)} consente di eliminare una conversazione (o marcarla come eliminata);
    \item \texttt{updateConversationTimestamp(conversationId)} aggiorna il timestamp di una conversazione.
\end{itemize}

\subsubsection*{Gestione dei messaggi}
Il sistema offre anche funzionalità per la gestione dei messaggi all’interno delle conversazioni:
\begin{itemize}
    \item \texttt{addMessage(conversationId, sender, content)} consente di aggiungere un nuovo messaggio a una conversazione esistente;
    \item \texttt{readMessages(conversationId)} restituisce tutti i messaggi di una determinata conversazione.
\end{itemize}

\subsubsection*{Gestione dei feedback}
Infine, la gestione dei feedback si articola in diversi metodi:
\begin{itemize}
    \item \texttt{readFeedback(messageId)} recupera il feedback associato a un messaggio specifico;
    \item \texttt{addFeedback(messageId, feedback, content)} permette di aggiungere un feedback a un messaggio esistente;
    \item \texttt{readNumPositiveFeedback()} e \texttt{readNumNegativeFeedback()} forniscono il conteggio dei feedback positivi e negativi;
    \item \texttt{readFeedbackWithComments()} recupera tutti i feedback che contengono anche dei commenti.
\end{itemize}

\subsubsubsubsection{Adapter - DBRepository}
Gli adattatori sono responsabili della comunicazione tra il core del sistema e il database. In particolare, \texttt{DBRepository} si occupa dell'esecuzione delle query SQL e della gestione dei risultati:
\begin{itemize}
    \item \texttt{executeQuery(query, params)} esegue una query SQL passando i parametri necessari;
    \item \texttt{fetchOne(query, params)} recupera un singolo risultato dalla query;
    \item \texttt{fetchAll(query, params)} restituisce tutti i risultati di una query;
    \item \texttt{close()} chiude la connessione al database.
\end{itemize}



\subsubsubsubsection{Adapter - ContextExtractorService}
Il \texttt{ContextExtractorService} ha il compito di individuare i prodotti e le porzioni di documentazione (chunk) presenti nel database che risultano più pertinenti e coerenti con il prompt fornito dall'utente.\\ Il processo di ricerca \`e stato diviso in 2 macro-operazioni:
\begin{enumerate}
    \item Ricerca prodotti pi\`u coerenti;
    \item Ricerca chunk pi\`u coerenti, tra quelli che appartengono ai prodotti selezionati.
\end{enumerate}
All'interno del file \texttt{ContextExtractorService.py} ci sono delle costanti che possono essere modificate per ``scalare" la soluzione (ad esempio, avendo a disposizione pi\`u potenza di calcolo):
\begin{enumerate}
    \item \texttt{SIMILARITY\_THRESHOLD} \`e la soglia sotto la quale un prodotto non viene considerato;
    \item \texttt{TOP\_SIMILAR\_CHUNKS} \`e il numero di chunk che vengono inseriti come contesto del prompt;
    \item \texttt{TOP\_PRODUCTS\_FINAL} \`e il numero di prodotti ``coerenti" dai quali documenti saranno estratti i \texttt{TOP\_SIMILAR\_CHUNKS}.
\end{enumerate}
\texttt{ContextExtractorService} contiene i seguenti metodi:
\begin{itemize}
    \item \texttt{processUserInput(userInput)} \`e il metodo principale della classe e orchestra l'estrazione dei dati coerenti dal Database.\\ \texttt{userInput} \`e il testo del prompt fatto dall'utente;
    \item \texttt{getStructuredProducts()} estrae dal Database le informazioni riguardanti id, titolo, descrizione di ogni prodotto, insieme a 3 vettori che rappresentano rispettivamente l'informazione di ``id prodotto", ``id e titolo prodotto" e ``id, titolo e descrizione prodotto";
    \item \texttt{findTopNSimilarProducts(prodList, promptVector, n)} trova gli \texttt{n} prodotti pi\`u simili al prompt, utilizzando i vettori sopra citati;
    \item \texttt{aggregateSimilarities(similarProducts)} aggrega le informazioni estratte da \texttt{findTopNSimilarProducts}, in questo modo per ogni prodotto si avr\`a un unico punteggio di similarit\`a;
    \item \texttt{selectChunksEmbeddings(chunks, aggregatedSimilarProduct)} seleziona i chunk dei documenti associati ai prodotti pi\`u simili, restituendo i vettori di embedding per il confronto;
    \item \texttt{findTopNSimilar(chunksEmbeddings, userEmbeddings, n)} trova gli \texttt{n} chunk pi\`u simili rispetto al prompt utente confrontando gli embedding tramite similarit\`a coseno;
    \item \texttt{extractEtim()} estrae dal Database l'informazione relativa agli ETIM (dati tecnici) dei prodotti;
    \item \texttt{selectEtim(etim, textsToEmbed)} associa le informazioni ETIM ai chunk selezionati come contesto, restituendo un dizionario che mappa gli identificativi di prodotto ai relativi codici ETIM;
    \item \texttt{getEmbedding(prompt)} utilizza il modello di embedding \texttt{mxbai-embed-large} per generare un vettore di embedding a partire dal testo del prompt;
    \item \texttt{getDocumentsByProductId(productId)} recupera dal Database i documenti associati a un determinato prodotto, includendo il titolo del prodotto e il titolo del documento;
    \item \texttt{loadChunks()} estrae dal Database tutti i chunk di documentazione, inclusi gli embedding associati, per consentire la ricerca di contenuti pertinenti.
\end{itemize}
\subsubsubsubsection{Adapter - LLMResponseService}
Il \texttt{LLMResponseService} ha il compito di interfacciarsi con un modello di linguaggio per ottenere una risposta contestualizzata basata su una conversazione in corso, una domanda utente e un insieme di informazioni di contesto estratte dal Database.
Negli attributi della classe \`e possibile configurare il modello di linguaggio, il default \`e \texttt{llama3.1:8b}.
\texttt{LLMResponseService} contiene il seguente metodo:
\begin{itemize}
    \item \texttt{getLlmResponse(conversationPile, question, textsToEmbed, etimToEmbed)} si occupa di formattare i messaggi della conversazione, aggregare il contesto rilevante e inviare la richiesta al modello LLM per ottenere una risposta.
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{images/BackendUML.jpeg}
    \caption{Schema delle classi utilizzate nel backend}
    \label{fig:architettura}
\end{figure}

\end{itemize}

\subsubsubsubsection{API - APIController}
Gli adattatori includono anche \texttt{APIController}, che gestisce gli endpoint delle API esposte dal sistema. Esistono vari endpoint per ciascuna delle operazioni descritte, a partire da quelli di test:
\begin{itemize}
    \item \texttt{testApi()} che consente di verificare il funzionamento generale del sistema.
\end{itemize}

\subsubsection*{Gestione delle sessioni}
\begin{itemize}
    \item \texttt{apiCreateSession()} per creare una nuova sessione;
    \item \texttt{apiUpdateSession(sessionId)} per aggiornare una sessione esistente.
\end{itemize}

\subsubsection*{Gestione delle conversazioni}
\begin{itemize}
    \item \texttt{apiCreateConversation()} per creare una conversazione;
    \item \texttt{apiReadConversations()} per ottenere tutte le conversazioni di una sessione;
    \item \texttt{apiReadConversationById(conversationId)} per ottenere una conversazione specifica;
    \item \texttt{apiDeleteConversation(conversationId)} per eliminare una conversazione;
    \item \texttt{apiUpdateConversationTimestamp(conversationId)} per aggiornare il timestamp della conversazione.
\end{itemize}

\subsubsection*{Gestione dei messaggi}
\begin{itemize}
    \item \texttt{apiAddMessage()} per aggiungere un nuovo messaggio;
    \item \texttt{apiReadMessages()} per recuperare i messaggi di una conversazione.
\end{itemize}

\subsubsection*{Gestione dei feedback}
\begin{itemize}
    \item \texttt{apiReadFeedbackByMessageId(messageId)} recupera il feedback associato a un messaggio;
    \item \texttt{apiAddFeedback()} permette di aggiungere un feedback.
\end{itemize}

\subsubsection*{Gestione della dashboard}
\begin{itemize}
    \item \texttt{apiReadNumPositiveFeedback()} e \texttt{apiReadNumNegativeFeedback()} per ottenere il numero di feedback positivi e negativi;
    \item \texttt{apiReadNumConversations()} per conoscere il numero totale di conversazioni;
    \item \texttt{apiReadFeedbackWithComments()} per ottenere feedback che includono commenti.
\end{itemize}

Gli endpoint sono protetti da un sistema di sicurezza, con il decoratore \texttt{requireAPIKey(f)} che garantisce l’autenticazione tramite chiave API. Inoltre, la configurazione di CORS permette di gestire le richieste provenienti dal frontend.

\subsubsection{Database}
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{images/DB.png}
    \caption{Diagramma Database}
    \label{fig:Diagramma Database}
\end{figure}

Nel database relazionale sono presenti sette tabelle per la persistenza delle informazioni da utilizzare nella RAG e delle conversazioni degli utenti.
\newline
Per quanto riguarda i dati relativi ai prodotti da utilizzare nelle fasi di ricerca del contesto per il modello di linguaggio ci sono tre tabelle di seguito descritte.
\begin{itemize}
    \item \textbf{Product}: immagazzina le informazioni primarie relative ai prodotti disponibili nel sito web
    \begin{itemize}
        \item id: l'id del prodotto, in formato testuale;
        \item title: il titolo o nome del prodotto;
        \item description: la breve descrizione del prodotto presente nella pagina web dedicata;
        \item etim: i dati tecnici del prodotto presenti nella pagina web dedicata, sottoforma di stringa ("key: value;") a causa della variabilità dei dati disponibili a seconda del tipo di prodotto;
        \item idVector: la vettorizzazione dell'id del prodotto per le ricerche;
        \item idTitleVector: la vettorizzazione dell'id insieme al titolo del prodotto per le ricerche;
        \item idTitleDescrVector: la vettorizzazione dell'insieme di id, titolo e descrizione del prodotto per le ricerche.
    \end{itemize}
    \item \textbf{Document}: immagazzina le informazioni dei documenti estratti dalle pagine web dei prodotti
     \begin{itemize}
        \item id: id univoco;
        \item title: il titolo del documento;
        \item productId: l'id del prodotto a cui fa riferimento.
    \end{itemize}
    \item \textbf{Chunk}: immagazzina le informazioni dei chunk creati a partire dai documenti
     \begin{itemize}
        \item id: id univoco;
        \item filename: il titolo del documento da cui è stato estratto il chunk;
        \item chunk: il testo del chunk;
        \item embedding: la vettorizzazione del chunk per le ricerche.
    \end{itemize} 
\end{itemize}
Per quanto riguarda invece il salvataggio e la permanenza delle conversazioni degli utenti vengono usate quattro tabelle di seguito descritte.
\begin{itemize}
    \item \textbf{Session}: contiene le sessioni, ovvero le connessioni degli utenti
    \begin{itemize}
        \item sessionId: id univoco che identifica la sessione dell'utente;
        \item createdAt: data e ora della creazione della sessione;
        \item updatedAt: data e ora dell'ultima modifica alla sessione;
        \item isActive: valore booleano che indica se la sessione sia ancora attiva o meno, di default a true, diventa automaticamente false dopo 30 giorni di inattività.
    \end{itemize} 
    \item \textbf{Conversation}: contiene le conversazioni degli utenti
    \begin{itemize}
        \item conversationId: id univoco;
        \item sessionId: id della sessione a cui appartiene;
        \item createdAt: data e ora della creazione della conversazione;
        \item updatedAt: data e ora dell'ultima modifica alla conversazione;
        \item toDelete: valore booleano che indica se la conversazione vada eliminata o meno, può diventare true su scelta dell'utente o allo scadere della sessione associata.
    \end{itemize} 
    \item \textbf{Message}: contiene tutti i messaggi inviati sia dagli utenti che dal modello LLM
    \begin{itemize}
        \item messageId: id univoco;
        \item conversationId: id della conversazione a cui appartiene;
        \item sender: indica se il messaggio è stato inviato dall'utente o è una risposta del modello;
        \item content: il contenuto del messaggio stesso;
        \item createdAt: data e ora della creazione del messaggio.
    \end{itemize} 
    \item \textbf{Feedback}: contiene i feedback lasciati dagli utenti
    \begin{itemize}
        \item feedbakcId: id univoco;
        \item messageId: id del messaggio su cui è stato creato il feedback;
        \item isHelpful: booleano, indica un feedback positivo o negativo;
        \item content: il contenuto del feedback qualora l'utente desiderasse lasciarlo;
        \item createdAt: data e ora della creazione del feedback.
    \end{itemize} 
\end{itemize}


\subsubsection{Elaborazione dei dati}
Una  componente essenziale per il funzionamento del prodotto è la raccolta dei dati dal sito web di Vimar e la loro elaborazione e salvataggio nel database. Queste attività sono ad opera del container  \texttt{dataProcessing} al cui avvio parte lo scraping del sito web che salva i dati dei prodotti in un file json. Successivamente lo stesso file è il punto di partenza per l'elaborazione dei dati e la generazione dei chunk a partire dai documenti associati ai prodotti, infine vi è il salvataggio nel database.  
Nel dettaglio:
\begin{itemize}
\item \texttt{productsElaboration.py} gestisce la manipolazione e l'analisi dei dati relativi ai prodotti, applicando eventuali filtri o trasformazioni;
\item \texttt{chunkElabotation.py} è particolarmente utile quando si lavora con grandi quantità di dati, poiché divide l'elaborazione in blocchi (chunk) per ottimizzare le prestazioni e ridurre il carico sulla memoria;
\item \texttt{embeddingLocal.py} è un modulo che si occupa della generazione di embedding locali,  utilizzati per analisi semantiche avanzate o per un sistema di raccomandazione basato su similarità tra prodotti;
\item \texttt{dataSaving.py} è il modulo che si occupa del salvataggio dei dati nel database.
\end{itemize}

L'esecuzione di questo container, che può richiedere diversi minuti, anche ore per la generazione dei chunk, si conclude dopo il salvataggio dei dati nel database.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{images/flussoSalvataggioDati.png}
    \caption{Diagramma delle attivit\`a del flusso di Elaborazione dati}
    \label{fig:architettura}
\end{figure}


\subsubsection{Dipendenze e tecnologie utilizzate}
L’elenco delle dipendenze è definito nel file requirements.txt, che include una serie di librerie fondamentali per il funzionamento del sistema:

\begin{itemize}
    
\item Flask per la gestione del server web tramite API;

\item Ollama per l’elaborazione del linguaggio naturale,  utilizzato per l'analisi dei testi associati ai prodotti;

\item PostgreSQL come database relazionale, scelto per la sua affidabilità e capacità di gestione di grandi volumi di dati;

\item Librerie per la manipolazione e l'analisi dei dati, come numpy e scikit-learn;

\item pypdf, che indica la funzionalità legata all'elaborazione di documenti PDF.

\end{itemize}
